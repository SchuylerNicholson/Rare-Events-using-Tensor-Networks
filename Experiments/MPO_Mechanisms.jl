function MPO_Mechanisms(sites,L,M,c,kw,cX)
    # using the specific keyword (kw), program will build an MPO which is generated by autoMPO

    ampo = AutoMPO();

    if cmp(kw,"Brusselator") == 0
        for i=1:Int(L)

            # B + X
            ampo .+= c[2]*NB, "ac_dag",2*i,"ac",2*i-1
            ampo .+= -c[2]*NB,"ac_dag",2*i-1,"ac",2*i-1
            ampo .+= c[2]*NB,"Fix_Norm",2*i,"ac_dag",2*i-1,"ac",2*i-1

            # 2X+Y reaction
            ampo .+= c[3],"ac_dag",2*i-1,"ac_dag",2*i-1,"ac_dag",2*i-1,"ac",2*i-1,"ac",2*i-1,"ac",2*i
            ampo .+=-c[3],"ac_dag",2*i-1,"ac_dag",2*i-1,"ac",2*i-1,"ac",2*i-1,"ac_dag",2*i,"ac",2*i
            ampo .+= c[3],"ac_dag",2*i-1,"ac_dag",2*i-1,"ac",2*i-1,"ac",2*i-1,"ac_dag",2*i,"ac",2*i,"Fix_Norm",2*i-1

            # A -> X
            ampo .+= c[1]*NA,"ac_dag",2*i-1
            ampo .+= -c[1]*NA,"IX",2*i-1

            # X -> ∅
            ampo .+= c[4],"ac",2*i-1
            ampo .+= -c[4],"ac_dag",2*i-1,"ac",2*i-1

            # Effective Hamiltonian for the Diffusion operators
            
            # X Diffusion
            #  X Hoping from right to left
            if i < L
            ampo .+= cX,"ac_dag",2*i+1,"ac",2*i-1
            ampo .+= -cX,"ac_dag",2*i-1,"ac",2*i-1
            ampo .+= cX,"ac_dag",2*i-1,"ac",2*i-1,"Fix_Norm",2*i+1
            #   X Hoping from left to right

            ampo .+= -cX,"ac_dag",2*i+1,"ac",2*i+1
            ampo .+= cX,"ac_dag",2*i-1,"ac",2*i+1
            ampo .+= cX,"ac_dag",2*i+1,"ac",2*i+1,"Fix_Norm",2*i-1
            end

            # Y Diffusion
            #   Y Hoping form right to left
            if i < L
            ampo .+= cY,"ac_dag",2*(i+1),"ac",2*i
            ampo .+= -cY,"ac_dag",2*i,"ac",2*i
            ampo .+= cY,"ac_dag",2*i,"ac",2*i,"Fix_Norm",2*(i+1)
            #   Y Hoping from left to right
            ampo .+= cY,"ac_dag",2*i,"ac",2*(i+1)
            ampo .+= -cY,"ac_dag",2*(i+1),"ac",2*(i+1)
            ampo .+= cY,"ac_dag",2*(i+1),"ac",2*(i+1),"Fix_Norm",2*i
            end
            
        end
    end

    if cmp(kw,"Schnakenberg") == 0
        for i=1:Int(L-1)
            #2X + Y -> 3X
            ampo .+= c[1],"ac_dag",2*i-1,"ac_dag",2*i-1,"ac_dag",2*i-1,"ac",2*i-1,"ac",2*i-1,"ac",2*i
            ampo .+=-c[1],"ac_dag",2*i-1,"ac_dag",2*i-1,"ac",2*i-1,"ac",2*i-1,"ac_dag",2*i,"ac",2*i
            ampo .+= c[1],"ac_dag",2*i-1,"ac_dag",2*i-1,"ac",2*i-1,"ac",2*i-1,"ac_dag",2*i,"ac",2*i,"Fix_Norm",2*i-1

            # A -> X
            ampo .+= c[2],"ac_dag",2*i-1
            ampo .+= -c[2],"IX",2*i-1

            # X -> A
            ampo .+= c[3],"ac",2*i-1
            ampo .+= -c[3],"ac_dag",2*i-1,"ac",2*i-1

            # B -> Y
            ampo .+= c[4],"ac_dag",2*i
            ampo .+= -c[4],"IX",2*i

            # Effective Hamiltonian for the Diffusion operators

            # X Diffusion
            #  X Hoping from right to left
            if i < L
                ampo .+= cDiff[1],"ac_dag",2*i+1,"ac",2*i-1
                ampo .+= -cDiff[1],"ac_dag",2*i-1,"ac",2*i-1
                ampo .+= cDiff[1],"ac_dag",2*i-1,"ac",2*i-1,"Fix_Norm",2*i+1
                #   X Hoping from left to right

                ampo .+= -cDiff[1],"ac_dag",2*i+1,"ac",2*i+1
                ampo .+= cDiff[1],"ac_dag",2*i-1,"ac",2*i+1
                ampo .+= cDiff[1],"ac_dag",2*i+1,"ac",2*i+1,"Fix_Norm",2*i-1
            end

            # Y Diffusion
            #   Y Hoping form right to left
            if i < L
                ampo .+= cDiff[2],"ac_dag",2*(i+1),"ac",2*i
                ampo .+= -cDiff[2],"ac_dag",2*i,"ac",2*i
                ampo .+= cDiff[2],"ac_dag",2*i,"ac",2*i,"Fix_Norm",2*(i+1)
                #   Y Hoping from left to right
                ampo .+= cDiff[2],"ac_dag",2*i,"ac",2*(i+1)
                ampo .+= -cDiff[2],"ac_dag",2*(i+1),"ac",2*(i+1)
                ampo .+= cDiff[2],"ac_dag",2*(i+1),"ac",2*(i+1),"Fix_Norm",2*i
            end
        end
    end

    if cmp(kw,"Schlogl") == 0
        for i = 1:Int(L)

            # 2X -> 3X
            ampo .+= c[1],"ac_dag",i,"ac_dag",i,"ac_dag",i,"ac",i,"ac",i
            ampo .+= -c[1],"ac_dag",i,"ac_dag",i,"ac",i,"ac",i
            ampo .+= c[1],"ac_dag",i,"ac_dag",i,"ac",i,"ac",i,"Fix_Norm",i

            # 3X -> 2X
            ampo .+= c[2],"ac_dag",i,"ac_dag",i,"ac",i,"ac",i,"ac",i
            ampo .+= -c[2],"ac_dag",i,"ac_dag",i,"ac_dag",i,"ac",i,"ac",i,"ac",i

            # ∅ -> X
            ampo .+= c[3],"ac_dag",i
            ampo .+= -c[3],"IX",i

            # X -> ∅
            ampo .+= c[4],"ac",i
            ampo .+= -c[4],"ac_dag",i,"ac",i

            # Diffusion
            #   Hoping from right to left

            if i < L
                # Hopping from Right to Left
                ampo .+= cX,"ac_dag",i+1,"ac",i
                ampo .+= -cX,"ac_dag",i,"ac",i
                ampo .+= cX,"ac_dag",i,"ac",i,"Fix_Norm",i+1
                #   Hoping from left to right
                ampo .+= cX,"ac_dag",i,"ac",i+1
                ampo .+= -cX,"ac_dag",i+1,"ac",i+1
                ampo .+= cX,"ac_dag",i+1,"ac",i+1,"Fix_Norm",i
            end

        end
    end

    # This is the version of the Schlogl Mechanism in which no probability can flow out of basin B 
    # This prevents re-crossings from being counted in rate calculations, which is especially important for small rates
    if cmp(kw,"Schlogl_NoBOutFlow") == 0
        ProjList= List_ProjectorCombinations(2::Int64,L::Int64) # 1=N 2 =
      
        for i = 1:Int(L)

            # 2X -> 3X -------------------------------------------------
            ampo .+= c[1],"ac_dag",i,"ac_dag",i,"ac_dag",i,"ac",i,"ac",i
            ampo .+= -c[1],"ac_dag",i,"ac_dag",i,"ac",i,"ac",i
            ampo .+= c[1],"ac_dag",i,"ac_dag",i,"ac",i,"ac",i,"Fix_Norm",i

            # 3X -> 2X -------------------------------------------------
            ampo .+= c[2],"ac_dag",i,"ac_dag",i,"ac",i,"ac",i,"ac",i
            ampo .+= -c[2],"ac_dag",i,"ac_dag",i,"ac_dag",i,"ac",i,"ac",i,"ac",i

            # ∅ -> X -------------------------------------------------
            ampo .+= c[3],"ac_dag",i
            ampo .+= -c[3],"IX",i

            # X -> ∅ -------------------------------------------------
            ampo .+= c[4],"ac",i
            ampo .+= -c[4],"ac_dag",i,"ac",i


            for k=1:Int(2^L-1)
                DetSign = length(findall(==(1),ProjList[k,:]))
                Assign = Generate_Projector_Assignment(ProjList[k,:])  # Old version
                #Assign = Generate_RxnProjector_Assignment(ProjList[k,:])
               # println("k is $k and the Set assignment is")
               
                H2X_1 = [(-1)^(DetSign)*c[1] "ac_dag" i "ac_dag" i "ac_dag" i "ac" i "ac" i]  #1st term in 2X -> 3X
                H2X_2 = [(-1)^(DetSign-1)*c[1] "ac_dag" i "ac_dag" i "ac" i "ac" i]           #2nd term in 2X -> 3X
                HXcre_1 = [(-1)^(DetSign)*c[3] "ac_dag" i]                                    #1st term in ∅ ->X
                HXcre_2 = [(-1)^(DetSign-1)*c[3] "IX" i]                                      #2nd term in ∅ ->X

            #    Assign = Generate_Projector_Assignment(ProjList[k,:])
                ampo .+= tuple(hcat(H2X_1,Assign)...)
                ampo .+= tuple(hcat(H2X_2,Assign)...)
                ampo .+= tuple(hcat(HXcre_1,Assign)...)
                ampo .+= tuple(hcat(HXcre_2,Assign)...)
            end

# ------------------- Diffusion ------------------------------------------------
            if i < L
                # Hopping from Right to Left -------------------------------------------------

                # Generate a projection list P_B(i)
                ampo .+= cX,"ac_dag",i+1,"ac",i
                ampo .+= -cX,"ac_dag",i,"ac",i
                ampo .+= cX,"ac_dag",i,"ac",i,"Fix_Norm",i+1

                ampo .+= cX,"ac_dag",i,"ac",i+1
                ampo .+= -cX,"ac_dag",i+1,"ac",i+1
                ampo .+= cX,"ac_dag",i+1,"ac",i+1,"Fix_Norm",i

                for k=1:Int(2^L-1)
                        DetSign = length(findall(==(1),ProjList[k,:]))
                        DRg = [(-1)^(DetSign)*cX "ac_dag" i+1 "ac" i]   # creation term for diffusing right to left
                        DR =  [(-1)^(DetSign-1)*cX "ac_dag" i "ac" i]  # Conservation term for diffusion right to left
                        DLg = [(-1)^(DetSign)*cX "ac_dag" i "ac" i+1]   # creation term for diffusing left to right
                        DL = [(-1)^(DetSign-1)*cX "ac_dag" i+1 "ac" i+1] # Conservation term for diffusion left to right

                        Assign = Generate_Projector_Assignment(ProjList[k,:])
                        ampo .+= tuple(hcat(DRg,Assign)...)     # This one checks out!
                        ampo .+= tuple(hcat(DR,Assign)...)       # This one checks out!
        
               end
            end

        end
    end
    H = MPO(ampo,sites);
end
